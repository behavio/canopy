# Canopy Java Parser: Design and Structure

## 1. Overview

The Java parser generated by Canopy is a packrat parser with memoization. It is created by a JavaScript-based builder (`src/builders/java.js`) that translates a Canopy grammar definition into a set of Java files. This generated parser can then take a string as input and produce a parse tree.

The core design principles are:

- **Builder Pattern**: A dedicated builder module in JavaScript (`java.js`) is responsible for traversing the grammar's Abstract Syntax Tree (AST) and generating the Java code.
- **Template-Based Code Generation**: The builder uses templates (e.g., `templates/java/Parser.java`, `templates/java/TreeNode.java`) for the boilerplate code of the parser and other classes.
- **Memoization**: The parser uses a `Map` to cache the results of parsing rules at different positions in the input string, avoiding redundant computations.
- **Left-Recursion Support**: The packrat parsing algorithm with memoization inherently supports left-recursive grammars.
- **Clear Separation of Concerns**: The generated code is organized into several classes, separating parsing logic (`Grammar`, `Parser`), data structures (`TreeNode`, `CacheRecord`), and user-defined actions (`Actions`).

## 2. Class Hierarchy

The generated Java parser consists of the following main classes, each in its own file:

### `Parser` (e.g., `JsonParser`)

This is the main class that the user interacts with, generated from the `templates/java/Parser.java` template. It extends the abstract `Grammar` class and is responsible for:

- Initializing the parser state.
- Starting the parsing process by calling the root rule's parsing method.
- Checking for a successful parse (the entire input must be consumed).
- Raising a `ParseError` if parsing fails.

### `Grammar` (abstract class)

This class contains the actual parsing logic. For each rule in the Canopy grammar, a corresponding `_read_<rule_name>()` method is generated in this class. It also holds the parser state, such as the input string, offset, cache, and failure information.

### `TreeNode`

This is the base class for all nodes in the generated parse tree, generated from `templates/java/TreeNode.java`. It provides:

- `text`: The portion of the input string that the node represents.
- `offset`: The starting position of the node's text in the input string.
- `elements`: A `List` of child `TreeNode` objects.

For grammar rules with specific names, named subclasses of `TreeNode` are generated.

### `ParseError`

A custom exception class that is raised when parsing fails. It contains information about the location of the error and what was expected at that point.

### `Actions`

An interface that defines the methods for any actions embedded in the grammar. The user provides a class implementing this interface.

### `CacheRecord`

A simple data class used by the memoization cache to store a parse result, containing the resulting `TreeNode` and the new offset (tail).

### `Label`

An `enum` that contains a constant for each rule name in the grammar. These labels are used as keys for the memoization cache.

## 3. Objects Interaction

1.  A `Parser` object (e.g., `JsonParser`) is instantiated with the input string and an optional object that implements the `Actions` interface.
2.  The `parse()` method of the `Parser` is called.
3.  `parse()` calls the `_read_<root_rule>()` method inherited from the `Grammar` class.
4.  Each `_read_<rule_name>()` method attempts to match a part of the input string.
5.  **Memoization**: Before attempting to parse, the method checks the cache (`Map<Label, Map<Integer, CacheRecord>>`) using the rule's `Label` and the current offset. If a `CacheRecord` is found, its result is used immediately.
6.  If a rule matches successfully:
    - A `TreeNode` object (or a subclass) is created.
    - A new `CacheRecord` is created with the `TreeNode` and the new offset, and it's stored in the cache.
    - The `TreeNode` is returned.
7.  If a rule fails to match:
    - A static `FAILURE` object is returned.
    - The failure is recorded in the cache.
    - The parser backtracks to try other alternatives or fails the parent rule.
8.  If the root rule matches and the entire input string is consumed, the `parse()` method returns the root `TreeNode`.
9.  Otherwise, a `ParseError` is raised with details about the failure.

## 4. Canopy Actions

Canopy allows embedding actions in the grammar, which are executed when a rule is successfully matched. The interaction with Java's static typing is a key aspect of this feature, providing both power and safety.

- **`Actions` Interface Generation**: The builder generates a public `Actions` interface. For each unique action tag in the grammar (e.g., `{ make_node }`), a corresponding method signature is added to this interface, like `TreeNode make_node(String input, int start, int end, List<TreeNode> elements);`.

- **Strict, Type-Safe Signatures**: The signature for every action method is strictly defined. It must accept the input `String`, integer `start` and `end` offsets, and a `List<TreeNode>` of child elements. Crucially, it must return a `TreeNode`. This ensures that any value returned by an action can be safely integrated into the parse tree.

- **User Implementation and Compile-Time Checking**: To use actions, you must provide a class that `implements` the generated `Actions` interface. The Java compiler enforces that your class correctly implements every method defined in the interface. This compile-time check prevents a whole class of runtime errors, such as misspelled action names or incorrect method signatures.

- **Type-Safe Tree Transformation**: When a rule with an action is matched, the parser calls the corresponding method on the user-provided `Actions` object. The `TreeNode` returned by this method replaces what would have been the default node in the parse tree. This allows for powerful, on-the-fly transformations of the tree in a completely type-safe manner.

## 5. Code Generation and Templates Use

The `src/builders/java.js` file is the core of the Java code generator. It traverses the grammar's AST and generates Java code for each element.

Key methods in `java.js`:

- `package_`: Creates files for `Actions` and `CacheRecord`.
- `grammarModule_`: Generates the abstract `Grammar` class.
- `parserClass_`: Generates the main `Parser` class, `ParseError`, and the `Label` enum.
- `syntaxNode_`: Generates the code to create a `TreeNode` instance or call an action.
- `cache_`: Generates the memoization logic for a rule.
- `_template`: Reads a template file from `templates/java/` and performs string substitution.

The generator uses the following templates from `templates/java/` to create the final set of Java files, which together form a self-contained parser for the defined grammar:

- `Actions.java`
- `CacheRecord.java`
- `Label.java`
- `ParseError.java`
- `Parser.java`
- `TreeNode.java`
