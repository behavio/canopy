# Canopy Python Parser: Design and Structure

## 1. Overview

The Python parser generated by Canopy is a packrat parser with memoization. It is created by a JavaScript-based builder (`src/builders/python.js`) that translates a Canopy grammar definition into a single Python file. This generated parser can then take a string as input and produce a parse tree.

The core design principles are:

- **Builder Pattern**: A dedicated builder module in JavaScript (`python.js`) is responsible for traversing the grammar's Abstract Syntax Tree (AST) and generating the Python code.
- **Template-Based Code Generation**: The builder uses templates (`templates/python/parser.py` and `templates/python/tree_node.py`) for the boilerplate code of the parser and the syntax tree nodes.
- **Memoization**: The parser uses a dictionary to cache the results of parsing rules at different positions in the input string. This avoids redundant parsing and ensures linear time complexity.
- **Left-Recursion Support**: The packrat parsing algorithm with memoization inherently supports left-recursive grammars.
- **Clear Separation of Concerns**: The generated code has a clear separation between the parsing logic (in the `Grammar` and `Parser` classes), the data structure for the parse tree (`TreeNode`), and user-defined actions.

## 2. Class Hierarchy

The generated Python parser consists of the following main classes:

### `Parser(Grammar)`

This is the main class that the user interacts with. It is responsible for:

- Initializing the parser state, including the input string, current offset, and cache.
- Starting the parsing process by calling the root rule's parsing method.
- Checking for successful parsing (the entire input is consumed).
- Raising a `ParseError` if parsing fails, providing detailed information about the failure.

The `Parser` class is generated from the `templates/python/parser.py` template.

### `Grammar(object)`

This class contains the actual parsing logic. For each rule in the Canopy grammar, a corresponding `_read_<rule_name>` method is generated in this class. These methods implement the logic for matching sequences, choices, terminals, etc. The `Parser` class inherits from the `Grammar` class to get access to these parsing methods.

### `TreeNode(object)`

This is the base class for all nodes in the generated parse tree. It provides the following attributes:

- `text`: The portion of the input string that the node represents.
- `offset`: The starting position of the node's text in the input string.
- `elements`: A list of child `TreeNode` objects.

The `TreeNode` class is generated from the `templates/python/tree_node.py` template. For grammar rules that have a specific name, a subclass of `TreeNode` is created with that name.

### `ParseError(SyntaxError)`

A custom exception class that is raised when parsing fails. It contains information about the location of the error and what was expected at that point.

## 3. Objects Interaction

The interaction between the objects is as follows:

1.  A `Parser` object is instantiated with the input string, an optional `actions` object, and an optional `types` object.
2.  The `parse()` method of the `Parser` is called.
3.  `parse()` calls the `_read_<root_rule>()` method, where `<root_rule>` is the starting rule of the grammar.
4.  Each `_read_<rule_name>()` method attempts to match a part of the input string according to the grammar rule.
5.  **Memoization**: Before attempting to parse a rule at a given offset, the parser checks if the result for that rule and offset is already in the cache. If so, the cached result is returned immediately.
6.  If a rule matches successfully:
    - A `TreeNode` object (or a subclass) is created to represent the matched part of the input.
    - The result (the `TreeNode` and the new offset) is stored in the cache.
    - The `TreeNode` is returned.
7.  If a rule fails to match:
    - A special `FAILURE` object is returned.
    - The failure is recorded in the cache.
    - The parser backtracks to try other alternatives in a choice, or fails the parent rule.
8.  If the root rule matches and the entire input string is consumed, the `parse()` method returns the root `TreeNode` of the parse tree.
9.  If the root rule does not match or the entire input is not consumed, a `ParseError` is raised.

## 4. Canopy Actions

Canopy allows you to embed actions in the grammar, which are code snippets that are executed when a rule is successfully matched. In the Python generator, these actions are handled as follows:

- The `actions` object passed to the `Parser` constructor should contain methods corresponding to the action names in the grammar.
- When a rule with an action is matched, the `syntaxNode_` method in `python.js` generates code to call the corresponding method on the `actions` object.
- The action method is called with the `input` string, the `start` and `end` offsets of the match, and a list of the child `elements`.
- The value returned by the action method replaces the `TreeNode` in the parse tree. This allows for transforming the parse tree during the parsing process.

## 5. Code Generation and Templates Use

The `src/builders/python.js` file is the core of the Python code generator. It works as a "builder" that traverses the AST of the Canopy grammar and generates Python code for each element.

Key methods in `python.js`:

- `package_`: Initializes the Python module with necessary imports.
- `class_`, `method_`, `constructor_`: Generate Python class and method definitions.
- `syntaxNode_`: Generates the code to create a `TreeNode` instance. If an action is present, it generates the call to the action method instead.
- `if_`, `loop_`: Generate conditional and loop statements.
- `cache_`: Generates the memoization logic for a rule.
- `_template`: Reads a template file from `templates/python/` and performs string substitution to insert generated code or grammar-specific names.

The generator uses the following templates from `templates/python/`:

- `parser.py`: This template provides the skeleton for the `Parser` class, the `ParseError` class, and the top-level `parse()` function. The `{{root}}` and `{{grammar}}` placeholders are filled in by the builder with the name of the root rule and the grammar name, respectively.
- `tree_node.py`: This template provides the `TreeNode` class definition. The `{{name}}` placeholder is used to create subclasses of `TreeNode` for named rules.

The final output is a single `.py` file containing the `Parser`, `Grammar`, `TreeNode`, and `ParseError` classes, along with all the parsing methods for the grammar rules. This file is self-contained and can be used to parse input strings according to the defined grammar.
