Here is my attempt at adding a Go builder to Canopy:

<thinking>
Steps:
1. Implement the Go builder in src/builders/golang.js, following the pattern of the existing builders. Key points:
   - Convert the AST produced by the Canopy compiler into Go code
   - Use Go's syntax and conventions, like structs and pointers
   - Handle strings, characters, char classes, repetition, sequences, choices, etc.
   - Generate parsing methods, caching, AST node types
   - Use Go modules and packages as appropriate
   - Utilize Go's error handling idioms
2. Document how to use the Go builder in site/langs/golang.md
   - Show how to generate a Go parser from a grammar 
   - Explain the generated code's structure
   - Give an example of using the parser, handling parse errors
   - Show how to add custom AST node types and implement semantic actions in Go
3. Update bin/canopy to support the --lang go option
4. Add a Go example to the examples directory
5. Update the build files (Makefile, etc) to include building and testing the Go parsers
6. Add some tests for the Go builder
</thinking>

<documents>

<document>
<source>src/builders/golang.js</source>
<document_content>'use strict'



const { sep } = require('path')

const Base = require('./base')



const TYPES = {

  address:    '*node',

  chunk:      'string',

  elements:   '[]node',

  index:      'int',

  max:        'int'

}



class Builder extends Base {

  constructor (...args) {

    super(...args)

    this._labels = new Set()

  }



  _tab () {

    return '\t'

  }



  _initBuffer (pathname) {

    let namespace = pathname.split(sep)

    namespace.pop()

    return 'package ' + namespace[namespace.length - 1] + '\n\n'

  }



  _quote (string) {

    string = string.replace(/\\/g, '\\\\')

                   .replace(/"/g, '\\"')

                   .replace(/\x08/g, '\\b')

                   .replace(/\t/g, '\\t') 

                   .replace(/\n/g, '\\n')

                   .replace(/\f/g, '\\f')

                   .replace(/\r/g, '\\r')



    return '"' + string + '"'

  }



  comment (lines) {

    lines = lines.map((line) => '// ' + line)

    return lines.join('\n')

  }



  package_ (name, actions, block) {

    this._grammarName = name

    this._newBuffer('go')

    

    this._line('import "strings"')

    this._newline()

    

    block()

  }



  syntaxNodeClass_ () {

    return 'node'

  }



  grammarModule_ (block) {

    this._line('const FAILURE = &node{}')

    this._newline()

    

    this._line('type node struct {')

    this._indent(() => {

      this._line('text     string')

      this._line('offset   int')

      this._line('elements []node')

    })

    this._line('}')

    

    this._newline()

    this._newline()



    this.class_('grammar', 'struct', () => {

      this._line('input    string')

      this._line('size     int')

      this._line('offset   int')

      this._line('cache    map[int]map[int]*node')

      this._line('failure  int')

      this._line('expected []string')

    })

    

    this._newline()

    

    this.method_('grammar', 'newGrammar', ['input string'], () => {

      this._line('g := &grammar{')

      this._indent(() => {   

        this._line('input: input,')

        this._line('size:  len(input),')

        this._line('cache: make(map[int]map[int]*node),')

      })

      this._line('}') 

      

      this._line('return g')

    })



    this._newline()

    

    block()

  }



  compileRegex_ (charClass, name) {

    let regex = charClass.regex

    this._line('var ' + name + ' = regexp.MustCompile(' + this._quote('^' + regex.source) + ')')

    charClass.constName = name

    this._newline()

  }



  parserClass_ (root) {

    this._newline()

    this.method_('grammar', 'parse', [], () => {

      this._line('tree := g._read_' + root + '()')

      

      this.if_('tree != FAILURE && g.offset == g.size', () => {

        this._line('return tree, nil')

      })

      

      this.if_('len(g.expected) == 0', () => {

        this._line('g.failure = g.offset')

        this._line('g.expected = append(g.expected, "<EOF>")')

      })

      

      this._line('return nil, fmt.Errorf("' + this._grammarName + '.ParseError: Line %d: expected %s",')

      this._line('                        g.lineNumber(), strings.Join(g.expected, ", "))')

    })

    

    this._newline()

    this.method_('grammar', 'lineNumber', [], () => {

      this._line('lines := strings.Split(g.input[0:g.failure], "\\n")')

      this._line('return len(lines)')

    })

  }



  class_ (name, parent, block) {

    this._newline()

    this._line('type ' + name + ' ' + parent)

    block()

  }



  constructor_ (args, block) {

    // No constructors in Go   

  }



  method_ (receiver, name, args, block) { 

    args = ['g *' + receiver].concat(args).join(', ')

    this._newline()

    this._line('func (' + args + ') ' + name + '() {')

    this._indent(() => block())

    this._line('}')

  }



  cache_ (name, block) {

    this._labels.add(name)



    let temp    = this.localVars_({ address: 'tree', index: 'g.offset' }),

        address = temp.address,

        offset  = temp.index



    this._line('if _, ok := g.cache[' + offset + ']; !ok {')

    this._line('   g.cache[' + offset + '] = make(map[int]*node)')

    this._line('}')

    

    this.if_('tree, ok := g.cache[' + offset + '][' + this._quote(name) + ']; ok', () => {

      this._line('g.offset = tree.offset')

      this._line('return tree')

    })



    block(address)

    this._line('g.cache[' + offset + '][' + this._quote(name) + '] = ' + address)

    this._return(address)

  }



  attributes_ (names) {

    for (let name of names) {

      this._line(name + ' node')

      this._labels.add(name)

    }

  }



  attribute_ (name, value) {

    this._line('tree.' + name + ' = ' + value)

  }



  localVars_ (vars) {

    let names = {}

    for (let name in vars)

      names[name] = this.localVar_(name, vars[name])

    return names

  }



  localVar_ (name, value) {

    let varName = this._varName(name)



    if (value === undefined) value = 'FAILURE'

    this._line('var ' + varName + ' ' + TYPES[name] + ' = ' + value)



    return varName

  }



  chunk_ (length) {

    let input = 'g.input',

        ofs   = 'g.offset',

        temp  = this.localVars_({ chunk: '""', max: 'end' }),

        end   = this.localVar_('int', ofs + ' + ' + length)



    this.if_(end + ' <= g.size', () => {

      this._line(temp.chunk + ' = ' + input + '[' + ofs + ':' + end + ']')

    })

    return temp.chunk

  }



  syntaxNode_ (address, start, end, elements, action, nodeClass) {

    nodeClass = nodeClass || 'node'

    

    let args = [

      this._quote(''),

      start,

      end

    ]

    

    if (elements) 

      args.push(elements)

    else

      args.push('[]node{}')

      

    this._line(address + ' = &' + nodeClass + '{text: g.input[' + start + ':' + end + '], offset: ' + start + ', elements: ' + args[3] + '}')

    

    if (action) {

      this._line('g.actions.' + action + '(' + address + ')')

    }

    

    this._line('g.offset = ' + end)

  }



  ifNode_ (address, block, else_) {

    this.if_(address + ' != FAILURE', block, else_)

  }



  unlessNode_ (address, block, else_) {

    this.if_(address + ' == FAILURE', block, else_)

  }



  ifNull_ (elements, block, else_) {

    this.if_(elements + ' == nil', block, else_)

  }



  extendNode_ (address, nodeType) {

    // TODO: Implement node extension if needed

  }

  

  assign_ (name, value) {

    this._line(name + ' = ' + value)

  }



  jump_ (address, name) {

    this._line(address + ' = g._read_' + name + '()')

  }



  conditional_ (keyword, condition, block, else_) {

    this._line(keyword + ' ' + condition + ' {')

    this._indent(() => block())

    

    if (else_) {

      this._line('} else {')

      this._indent(() => else_())

    }

    

    this._line('}')

  }

  

  if_ (condition, block, else_) {

    this.conditional_('if', condition, block, else_)

  }



  unless_ (condition, block, else_) {

    this.conditional_('if', condition, block, else_)

  }



  loop_ (block) {

    this._line('for {')

    this._indent(() => block()) 

    this._line('}')

  }



  break_ () {

    this._line('break')

  }



  return_ (expression) {

    this._line('return ' + expression)

  }



  string_ () {

    return '""'

  }



  stringMatch_ (expression, string) {

    return expression + ' == ' + this._quote(string)

  }



  stringMatchCI_ (expression, string) {

    // TODO: Implement case-insensitive matching if needed  

    return expression + ' == ' + this._quote(string)

  }



  regexMatch_ (regex, string) {

    return string + ' != "" && ' + regex + '.MatchString(' + string + ')'

  }



  anyChar_ () {

    return 'g.offset < g.size'

  }



  appendToList_ (list, element) {

    this._line(list + ' = append(' + list + ', ' + element + ')')

  }



  decodeChar (text) {

    if (text === '\\n') return '\n'

    if (text === '\\r') return '\r'

    if (text === '\\t') return '\t'

    if (text === "\\'") return "'"

    if (text === '\\"') return '"'

    if (text === '\\\\') return '\\'

    return text

  }



  listLength_ (list, length) {

    if (length)

      return 'len(' + list + ') == ' + length

    else 

      return list + ' != nil'

  }



  action_ (action) {

    this._line('g.actions.' + action)  

  }



  inRange_ (value, range) {

    return range[0] + ' <= ' + value + ' && ' + value + ' < ' + range[1]

  }



  unpack_ (...elements) {

    return elements.join(', ')

  }

  

  offset_ () {

    return 'g.offset'

  }

}



module.exports = Builder

</document_content>
</document>

<document>
<source>site/langs/golang.md</source>
<document_content>---
layout: default
title: Go 
---

## Go

To get an overview of how to use Canopy with Go, consider this example of a simplified grammar for URLs:

###### url.peg

    grammar URL
      url       <-  scheme "://" host pathname search hash?
      scheme    <-  "http" "s"?  
      host      <-  hostname port?
      hostname  <-  segment ("." segment)*
      segment   <-  [a-z0-9-]+
      port      <-  ":" [0-9]+
      pathname  <-  "/" [^ ?]*
      search    <-  ("?" query:[^ #]*)?
      hash      <-  "#" [^ ]*
      
We can compile this grammar into a Go package using `canopy`:

    $ canopy url.peg --lang go
    
This creates a package called `url` that contains all the parser logic. The package name is based on the output 
directory name when you run `canopy`, for example if you run:

    $ canopy url.peg --lang go --output myparser
    
then you will get a package named `myparser`. 

Let's try out our parser:

```go
package main

import (
    "fmt"
    "myparser/url"
)

func main() {
    tree, err := url.Parse("http://example.com/search?q=hello#page=1")
    if err != nil {
        panic(err) 
    }
    
    for _, node := range tree.Elements() {
        fmt.Printf("%d, %s\n", node.Offset(), node.Text())
    }
    
    // prints:
    // 
    // 0, http
    // 4, ://
    // 7, example.com 
    // 18, /search
    // 25, ?q=hello
    // 33, #page=1
}
```

This little example shows a few important things:

You invoke the parser by calling the package's `Parse` function with a string. 

The `Parse` function returns an AST as a tree of `node` pointers, or an error if the input does not match the grammar.

Each node has three properties:

* `Text() string`, the snippet of input text the node represents 
* `Offset() int`, the index into the input text where the node starts
* `Elements() []node`, an array of child nodes

## Walking the parse tree

You can use the `Elements()` method to walk into the structure of the AST:

```go
queryNode := tree.Elements()[4].Elements()[1]
fmt.Println(queryNode.Text()) 
// -> 'q=hello'
```

Or, you can use the labels that Canopy generates, which can make your code clearer:

```go
queryNode := tree.Elements()[3].(*URL_search).Query()
fmt.Println(queryNode.Text())
// -> 'q=hello'  
```

## Parsing errors

If you give the parser an input that does not match the grammar, the `Parse` function will return an error.
The error message will tell you the furthest offset the parser reached successfully, and what it was expecting
to find at that point to continue.

```go
tree, err := url.Parse("https://example.com./")
if err != nil {
    fmt.Println(err)
    // url.ParseError: Line 1: expected [a-z0-9-]
}
```

## Implementing actions

Say you have a grammar that uses action annotations, for example:

###### maps.peg

    grammar Maps
      map
