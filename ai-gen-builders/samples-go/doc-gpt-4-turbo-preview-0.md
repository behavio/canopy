```markdown
---
layout: default
title: Go
---

## Go

To get an overview of how to use Canopy with Go, consider this example of a
simplified grammar for URLs:

###### url.peg

    grammar URL
      url       <-  scheme "://" host pathname search hash?
      scheme    <-  "http" "s"?
      host      <-  hostname port?
      hostname  <-  segment ("." segment)*
      segment   <-  [a-z0-9-]+
      port      <-  ":" [0-9]+
      pathname  <-  "/" [^ ?]*
      search    <-  ("?" query:[^ #]*)?
      hash      <-  "#" [^ ]*

We can compile this grammar into Go source files using `canopy`:

    $ canopy url.peg --lang go

This creates a Go package containing all the parser logic. The `--output` option can be used to specify the directory where the generated files should go:

    $ canopy url.peg --lang go --output some/dir/url

This will write the generated parser into the directory `some/dir/url` as Go source files.

Let's use our parser:

```go
package main

import (
    "fmt"
    "url" // import the package generated by Canopy
)

func main() {
    tree, err := url.Parse("http://example.com/search?q=hello#page=1")
    if err != nil {
        panic(err)
    }

    for _, node := range tree.Elements {
        fmt.Printf("%d, %s\n", node.Offset, node.Text)
    }

    // prints:

    // 0, http
    // 4, ://
    // 7, example.com
    // 18, /search
    // 25, ?q=hello
    // 33, #page=1
}
```

This demonstrates how to invoke the parser, handle parsing errors, and iterate through the parsed elements. The `Parse` function returns a tree of nodes, each with the following properties:

* `Text` - the portion of the input text that the node represents
* `Offset` - the position in the input text where the node begins
* `Elements` - an array of child nodes

## Walking the parse tree

You can navigate through the parse tree by accessing the `Elements` property of nodes:

```go
package main

import (
    "fmt"
    "url"
)

func main() {
    tree, _ := url.Parse("http://example.com/search?q=hello#page=1")
    fmt.Println(tree.Elements[4].Elements[1].Text) // -> "q=hello"
}
```

## Parsing errors

If the input text does not match the grammar, the `Parse` function returns a `ParseError` detailing the nature of the mistake:

```go
package main

import (
    "fmt"
    "url"
)

func main() {
    _, err := url.Parse("https://example.com./")
    if err != nil {
        fmt.Println(err)
        // Output: Parse error: expected one of:
        // - [a-z0-9-] from URL::segment
        //
        // 1 | https://example.com./
        //                         ^
    }
}
```

## Implementing actions

Say you have a grammar that uses action annotations:

###### maps.peg

    grammar Maps
      map     <-  "{" string ":" value "}" %make_map
      string  <-  "'" [^']* "'" %make_string
      value   <-  list / number
      list    <-  "[" value ("," value)* "]" %make_list
      number  <-  [0-9]+ %make_number

In Go, you implement action functions as methods of a struct. This struct is then passed to the parser which calls the appropriate method when parsing a construct that has an associated action:

```go
package main

import (
    "fmt"
    "maps"
)

type MyActions struct{}

func (a *MyActions) MakeMap(input string, start, end int, elements []*maps.Node) interface{} {
    m := make(map[string]interface{})
    m[elements[1].Text] = elements[3].Data
    return m
}

func (a *MyActions) MakeString(input string, start, end int, elements []*maps.Node) interface{} {
    return elements[1].Text
}

func (a *MyActions) MakeList(input string, start, end int, elements []*maps.Node) interface{} {
    var list []interface{}
    list = append(list, elements[1].Data)
    for _, element := range elements[2].Elements {
        list = append(list, element.Data)
    }
    return list
}

func (a *MyActions) MakeNumber(input string, start, end int, elements []*maps.Node) interface{} {
    var number int
    fmt.Sscanf(input[start:end], "%d", &number)
    return number
}

func main() {
    parser := maps.NewParser()
    parser.Actions = &MyActions{}
    result, _ := parser.Parse("{'ints':[1,2,3]}")
    fmt.Println(result.Data)
    // Output: map[ints:[1 2 3]]
}
```

## Extended node types

While Go does not support inline class extensions in grammar annotations like some other languages, you can still achieve similar functionality by defining custom structs in your action functions and returning them to be part of the parse tree.

```markdown
```