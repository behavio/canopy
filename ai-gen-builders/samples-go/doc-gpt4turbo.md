---
layout: default
title: Go
---

## Go

To understand how to use Canopy with Go, let's examine a simplified grammar for URLs as an example:

###### url.peg

    grammar URL
      url       <-  scheme "://" host pathname search hash?
      scheme    <-  "http" "s"?
      host      <-  hostname port?
      hostname  <-  segment ("." segment)*
      segment   <-  [a-z0-9-]+
      port      <-  ":" [0-9]+
      pathname  <-  "/" [^ ?]*
      search    <-  ("?" query:[^ #]*)?
      hash      <-  "#" [^ ]*

You can compile this grammar into a Go package using `canopy`:

    $ canopy url.peg --lang go

This command generates Go source files within a package corresponding to the grammar. The location where files are generated by default is in the current directory, but this can be customized using the `--output` option:

    $ canopy url.peg --lang go --output some/dir/url

This command writes the generated parser into the directory `some/dir/url` under Go source files.

### Trying out the parser:

```go
package main

import (
    "fmt"
    "url" // Import the generated package
)

func main() {
    tree, err := url.Parse("http://example.com/search?q=hello#page=1")
    if err != nil {
        panic(err)
    }

    for _, node := range tree.Elements {
        fmt.Println(node.Offset, ", ", node.Text)
    }

    //   prints:
    //   0 , http
    //   4 , ://
    //   7 , example.com
    //   18 , /search
    //   25 , ?q=hello
    //   33 , #page=1
}
```

This example demonstrates how to invoke the parser by calling the package's `Parse()` function with a string. The `Element` structure in Go represents nodes in the parse tree, with the following fields:

- `Text` is the slice of the input text represented by the node.
- `Offset` is the starting position of the node in the input text.
- `Elements` is a slice containing nodes matching the sub-expressions.

### Walking the parse tree

You can walk the parse tree using the `Elements` slice:

```go
fmt.Println(tree.Elements[4].Elements[1].Text)
// Outputs: 'q=hello'
```

Or, use the labels generated by Canopy for clearer code:

```go
// Assuming 'Search' and 'Query' are defined as struct types for labeled elements
fmt.Println(tree.Search.Query.Text)
// Outputs: 'q=hello'
```

### Parsing errors

If the parser receives input that doesn't match the grammar, it returns an error of type `url.ParseError`. This error includes details about the expected characters or character classes at the point the parser could not proceed, along with the rule name and position in the input where the syntax error occurred.

```go
_, err := url.Parse("https://example.com./")
if err != nil {
    fmt.Println(err)
}

// Outputs an error detailing the expected characters, rule name, and position, e.g.,
//
// url.ParseError: Line 1: expected one of:
//
//     - [a-z0-9-] from URL::segment
//
//      1 | https://example.com./
//                              ^
```

### Implementing actions

Suppose you have a grammar utilizing action annotations:

###### maps.peg

    grammar Maps
      map     <-  "{" string ":" value "}" %make_map
      string  <-  "'" [^']* "'" %make_string
      value   <-  list / number
      list    <-  "[" value ("," value)* "]" %make_list
      number  <-  [0-9]+ %make_number

In Go, compiling this grammar produces a package with functions for every action specified in the grammar. For each action, such as `%make_map`, you would define a corresponding Go function that processes the parsed elements and returns a result.

It's typical in Go to define a struct type for the parser that embeds the generated parser type and then attach methods to this struct for each action:

```go
package main

import (
    "fmt"
    "maps" // Assume this is the generated package
)

type MyActions struct {
    maps.BaseActions // Embedding generated BaseActions
}

func (a *MyActions) MakeMap(input string, start, end int, elements []*maps.TreeNode) *maps.TreeNode {
    // Implementation of %make_map
}

func (a *MyActions) MakeString(input string, start, end int, elements []*maps.TreeNode) *maps.TreeNode {
    // Implementation of %make_string
}

// Add implementations for MakeList and MakeNumber...

func main() {
    actions := &MyActions{}
    result, err := maps.Parse("{'ints':[1,2,3]}", actions)
    if err != nil {
        panic(err)
    }

    fmt.Println(result)
    // Outputs the parsed structure
}
```

### Extended node types

As of the provided examples and toolkit capabilities, extending node types with custom behavior in Go involves struct embedding and overriding methods in a similar manner as done with actions. Each node in the parse tree is represented by a `*maps.TreeNode` which can be composed into custom structs with additional methods or properties as needed for your parsing logic.

```
Note: The functionality and approach for Go may vary depending on the current capabilities of the Canopy parser generator and the Go language specifics not covered in the Python and Java examples. Always refer to the latest Canopy documentation and Go language best practices.
```