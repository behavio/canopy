```markdown
---
layout: default
title: Go
---

## Go

To understand how to use Canopy to generate Go parsers, let's start with a simplified grammar for URLs:

###### url.peg

    grammar URL
      url       <-  scheme "://" host pathname search hash?
      scheme    <-  "http" "s"?
      host      <-  hostname port?
      hostname  <-  segment ("." segment)*
      segment   <-  [a-z0-9-]+
      port      <-  ":" [0-9]+
      pathname  <-  "/" [^ ?]*
      search    <-  ("?" query:[^ #]*)?
      hash      <-  "#" [^ ]*

To compile this grammar into a Go package using `canopy`, you would use:

    $ canopy url.peg --lang go

This generates a Go package that includes all the parser logic required to parse URLs according to our grammar. If you prefer to specify the output directory or package name, you can use the `--output` option:

    $ canopy url.peg --lang go --output some/dir/url

This command writes the generated parser as Go source files into `some/dir/url`.

Let's use our parser:

```go
package main

import (
	"fmt"
	"url" // Make sure to import the generated package correctly
)

func main() {
	tree, err := url.Parse("http://example.com/search?q=hello#page=1")
	if err != nil {
		fmt.Println(err)
		return
	}

	for _, node := range tree.Elements {
		fmt.Printf("%d, %s\n", node.Offset, node.Text)
	}

	// Output:
	// 0, http
	// 4, ://
	// 7, example.com
	// 18, /search
	// 25, ?q=hello
	// 33, #page=1
}
```

### Walking the parse tree

In Go, you can directly access the elements of the parse tree to navigate its structure. Alternatively, the labels generated by Canopy can also help you access specific parts of the parse tree clearer:

```go
package main

import (
	"fmt"
	"url"
)

func main() {
	tree, err := url.Parse("http://example.com/search?q=hello#page=1")
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Println(tree.GetElement("search").GetElement("query").Text)
	// Output: 'q=hello'
}
```

### Parsing errors

Should the input text not match the defined grammar, the Go parser will return an error detailing what was expected at the furthest position it managed to parse:

```go
package main

import (
	"fmt"
	"url"
)

func main() {
	_, err := url.Parse("https://example.com./")
	if err != nil {
		fmt.Println(err)
		// url.ParseError: Line 1: expected one of:
		//
		//     - [a-z0-9-] from URL::segment
		//
		//      1 | https://example.com./
		//                              ^
	}
}
```

### Implementing actions

For grammars utilizing action annotations, Go code generation produces a package containing a `Parser` struct with methods corresponding to action names defined in the grammar. Actions must be implemented as methods receiving a `*Parser`, string, start and end positions, and a slice of elements, and they should return a custom `TreeNode`:

###### maps.peg

    grammar Maps
      map     <-  "{" string ":" value "}" %make_map
      string  <-  "'" [^']* "'" %make_string
      value   <-  list / number
      list    <-  "[" value ("," value)* "]" %make_list
      number  <-  [0-9]+ %make_number

To parse an input like `{'ints':[1,2,3]}`, you define custom `TreeNode` structs for each action and implement the action methods:

```go
package main

import (
	"fmt"
	"maps"
)

type Map struct {
	maps.TreeNode
	Value map[string]interface{}
}

type String struct {
	maps.TreeNode
	Value string
}

type List struct {
	maps.TreeNode
	Value []interface{}
}

type Number struct {
	maps.TreeNode
	Value int
}

func (p *maps.Parser) Make_map(input string, start, end int, elements []maps.TreeNode) maps.TreeNode {
	key := elements[1].(String).Value
	value := elements[3].(List).Value
	return Map{Value: map[string]interface{}{key: value}}
}

func (p *maps.Parser) Make_string(input string, start, end int, elements []maps.TreeNode) maps.TreeNode {
	return String{Value: input[start+1 : end-1]}
}

func (p *maps.Parser) Make_list(input string, start, end int, elements []maps.TreeNode) maps.TreeNode {
	list := List{Value: make([]interface{}, 0)}
	list.Value = append(list.Value, elements[1])
	for _, el := range elements[2:] {
		list.Value = append(list.Value, el)
	}
	return list
}

func (p *maps.Parser) Make_number(input string, start, end int, elements []maps.TreeNode) maps.TreeNode {
	// Conversion logic omitted for brevity
	return Number{/* Converted value from input[start:end] */}
}

func main() {
	var parser maps.Parser
	tree, err := parser.Parse("{'ints':[1,2,3]}", maps.Actions{Make_map: parser.Make_map, Make_string: parser.Make_string, Make_list: parser.Make_list, Make_number: parser.Make_number})

	if err != nil {
		fmt.Println(err)
		return
	}

	result := tree.(Map).Value
	fmt.Println(result)
	// Output: map[ints:[1 2 3]]
}
```

### Extended node types

Currently, Go does not support direct grammar annotations for extended node types as seen in other languages' implementations.
```
