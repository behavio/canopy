```---
layout: default
title: Go
---

## Go

To get an overview of how to use Canopy with Go, consider this example of a
simplified grammar for URLs:

###### url.peg

```
grammar URL
  url       <-  scheme "://" host pathname search hash?
  scheme    <-  "http" "s"?
  host      <-  hostname port?
  hostname  <-  segment ("." segment)*
  segment   <-  [a-z0-9-]+
  port      <-  ":" [0-9]+
  pathname  <-  "/" [^ ?]*
  search    <-  ("?" query:[^ #]*)?
  hash      <-  "#" [^ ]*
```

We can compile this grammar into a Go package using `canopy`:

```
$ canopy url.peg --lang go
```

This creates a package called `url` that contains all the parser logic. The
package name is based on the path to the `.peg` file when you run `canopy`. The
`--output` option can be used to override this, for example:

```
$ canopy some/dir/url.peg --lang go --output com/jcoglan/canopy/url
```

Let's try our parser out:

```go
package main

import (
	"fmt"
	"url"
)

func main() {
	tree, err := url.Parse("http://example.com/search?q=hello#page=1")
	if err != nil {
		panic(err)
	}

	for _, node := range tree.Elements {
		fmt.Println(node.Offset, node.Text)
	}

	/*  prints:

	    0, http
	    4, ://
	    7, example.com
	    18, /search
	    25, ?q=hello
	    33, #page=1       */
}
```

This example illustrates the key aspects:

- Invoking the parser by calling the module's `Parse()` function with a string.
- The `Parse()` method returns a tree of *nodes*.
- Each node has three properties:
  - `Text`, the snippet of the input text that node represents
  - `Offset`, the number of characters into the input text the node appears
  - `Elements`, a slice of nodes matching the sub-expressions

## Walking the parse tree

You can use the `Elements` slice to navigate through the tree structure:

```go
fmt.Println(tree.Elements[4].Elements[1].Text)
// -> 'q=hello'
```

Alternatively, you can access nodes by using the labels generated by Canopy for clearer code:

```go
fmt.Println(tree.Search.Query.Text)
// -> 'q=hello'
```

## Parsing errors

If the parser encounters input that does not conform to the grammar, a `ParseError` will be raised. The error message will indicate the expected characters or strings and highlight the position of the syntax error in the input line.

```go
_, err := url.Parse("https://example.com./")
fmt.Printf("url.ParseError: %s\n", err)
```

## Implementing actions

For parsers with action annotations, you can supply the action functions to the parser by implementing methods defined in the grammar. Here is an example using a grammar for Maps:

###### maps.peg

```
grammar Maps
  map     <-  "{" string ":" value "}" {device.make_map}
  string  <-  "'" [^']* "'" {device.make_string}
  value   <-  list / number
  list    <-  "[" value ("," value)* "]" {device.make_list}
  number  <-  [0-9]+ {device.make_number}
```

In Go, the generated package will contain methods to implement these actions. Below is a complete example:

```go
package main

import (
	"fmt"
	"maps"
)

type Device struct{}

func (d *Device) MakeMap(input string, start int, end int, elements []*maps.TreeNode) interface{} {
	return map[string]interface{}{
		elements[1].Text: elements[3],
	}
}

func (d *Device) MakeString(input string, start int, end int, elements []*maps.TreeNode) interface{} {
	return elements[1].Text
}

func (d *Device) MakeList(input string, start int, end int, elements []*maps.TreeNode) interface{} {
	var list []interface{}
	list = append(list, elements[1])
	for _, el := range elements[2] {
		list = append(list, el.Value)
	}
	return list
}

func (d *Device) MakeNumber(input string, start int, end int, elements []*maps.TreeNode) interface{} {
	num, err := strconv.Atoi(input[start:end])
	if err != nil {
		panic(err)
	}
	return num
}

func main() {
	device := &Device{}
	result, err := maps.Parse("{'ints':[1,2,3]}", device)
	if err != nil {
		panic(err)
	}

	fmt.Println(result)
	// -> {'ints': [1, 2, 3]}
}
```

The above code demonstrates how to define a type with methods corresponding to the actions in the grammar and then use these methods to parse input strings and perform actions accordingly.

## Extended node types

Using the `<Type>` annotation in the grammar is not supported in the Go version of Canopy.
```