---
layout: default
title: Go
---

## Go

To get an understanding of how Canopy can be utilized with Go, let's explore an example involving a simplified grammar for URLs:

###### url.peg

```
grammar URL
  url       <-  scheme "://" host pathname search hash?
  scheme    <-  "http" "s"?
  host      <-  hostname port?
  hostname  <-  segment ("." segment)*
  segment   <-  [a-z0-9-]+
  port      <-  ":" [0-9]+
  pathname  <-  "/" [^ ?]*
  search    <-  ("?" query:[^ #]*)?
  hash      <-  "#" [^ ]*
```

To compile this grammar into a Go package using `canopy`, run the following command:

```
$ canopy url.peg --lang go
```

This command generates a Go package in a directory with the same name as the `.peg` file (`url` in this case), containing all necessary parser logic. The package name is derived from the path to the `.peg` file when you execute `canopy`. For instance:

```
$ canopy com/jcoglan/canopy/url.peg --lang go
```

This will yield a package named `com/jcoglan/canopy/url`. The `--output` option can override the default package name and directory:

```
$ canopy com/jcoglan/canopy/url.peg --lang go --output some/dir/url
```

This will place the generated files into `some/dir/url`, with the package set accordingly.

### Trying Out the Parser

```go
package main

import (
    "fmt"
    "log"
    "url"
)

func main() {
    tree, err := url.Parse("http://example.com/search?q=hello#page=1")
    if err != nil {
        log.Fatal(err)
    }

    for _, node := range tree.Elements {
        fmt.Printf("%d, %s\n", node.Offset, node.Text)
    }
    // prints:
    // 0, http
    // 4, ://
    // 7, example.com
    // 18, /search
    // 25, ?q=hello
    // 33, #page=1
}
```

### Highlights

- You invoke the parser by calling the package's `Parse()` function, passing it a string.
- The `Parse()` method returns a tree of *Nodes*.
- Each *Node* has:
  - `Text`, the snippet of the input text that node represents
  - `Offset`, how many characters into the input the node appears
  - `Elements`, an array of nodes matching the subexpressions

### Walking the Parse Tree

You can navigate the structure of the tree using `Elements`, or use the labels Canopy generates for a more understandable code interface:

```go
package main

import (
    "fmt"
    "log"
    "url"
)

func main() {
    tree, err := url.Parse("http://example.com/search?q=hello#page=1")
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println(string(tree.Elements[4].Elements[1].Text))
    // Output: 'q=hello'
}
```

### Parsing Errors

If the input text doesn't match the grammar, Canopy generates a parsing error detailing the expectations at the furthest reached position:

```go
package main

import (
    "fmt"
    "log"
    "url"
)

func main() {
    _, err := url.Parse("https://example.com./")
    if err != nil {
        fmt.Println(err)
    }
    // Output similar to:
    // url.ParseError: Line 1: expected one of:
    // - [a-z0-9-] from URL::segment
    //  1 | https://example.com./
    //                              ^
}
```

### Implementing Actions

Given a grammar utilizing action annotations, like:

###### maps.peg

```
grammar Maps
  map     <-  "{" string ":" value "}" %make_map
  string  <-  "'" [^']* "'" %make_string
  value   <-  list / number
  list    <-  "[" value ("," value)* "]" %make_list
  number  <-  [0-9]+ %make_number
```

In Go, after compiling the above grammar, you could implement custom actions for each rule:

```go
// Implementation of actions in Go would depend on the specifics of Canopy's Go code generation.
// The example assumes the existence of an Actions interface and a TreeNode struct.
```

Due to Go being strongly typed and not supporting generics in a way comparable to Python or Java, this pseudocode aims to portray the intention. The actual implementation will depend on how Canopy generates Go parsers and interfaces for actions and nodes.

### Extended Node Types

Go does not support runtime type annotations in the same way that Python does. However, you can use interfaces and type assertions to achieve polymorphic behavior for node types in your parsers.

For comprehensive examples and implementation details, it would be wise to refer to the specific documentation and API generated by Canopy for Go parsers.

```
This documentation assumes a hypothetical implementation of Canopy for Go following similar patterns as its Java and Python counterparts. Adjustments might be necessary based on the actual implementation provided by Canopy for Go.
